# Assets Module: Supabase to SharePoint Migration Plan

## Table of Contents
1. [Overview](#overview)
2. [Migration Strategy](#migration-strategy)
3. [SharePoint List Schema](#sharepoint-list-schema)
4. [Architecture Design](#architecture-design)
5. [Implementation Phases](#implementation-phases)
6. [Data Migration Process](#data-migration-process)
7. [Code Changes Required](#code-changes-required)
8. [Testing Strategy](#testing-strategy)
9. [Rollback Plan](#rollback-plan)

---

## Overview

### Current State (Supabase)
- **Database Table**: `public.assets` in Supabase PostgreSQL
- **Total Records**: 161 assets
- **Data Retrieval**: Supabase Edge Function (`get-assets`)
- **Authentication**: Microsoft JWT token verification
- **Filtering**: Role-based (admin sees all, users see only their assigned assets)
- **Real-time**: Supabase Realtime subscriptions enabled

### Target State (SharePoint)
- **SharePoint List**: `Assets` (or unit-specific lists if needed)
- **Location**: `/sites/scpngintranet`
- **Access Method**: Microsoft Graph API
- **Authentication**: Microsoft Graph SDK with existing MSAL tokens
- **Real-time**: Microsoft Graph webhooks/change notifications (optional)

### Benefits of Migration
âœ… **Unified Platform**: All organizational data in Microsoft 365
âœ… **Better Integration**: Native SharePoint features (versioning, workflows, Power Automate)
âœ… **Simplified Permissions**: Microsoft 365 group-based access control
âœ… **Cost Optimization**: Reduce Supabase dependency
âœ… **Enhanced Collaboration**: SharePoint's document management for asset images/invoices

---

## Migration Strategy

### Option 1: Single Centralized Assets List (Recommended)
**List Name**: `Assets`

**Pros**:
- Simple architecture
- Single source of truth
- Easier to manage permissions
- Better for cross-unit asset searches
- Follows your current Supabase model

**Cons**:
- Requires proper filtering by division/unit
- Slightly more complex permission setup

### Option 2: Division-Specific Assets Lists
**List Names**: `IT_Assets`, `HR_Assets`, `Finance_Assets`, etc.

**Pros**:
- Clear data isolation
- Simpler permissions per division
- Follows the Unit page migration pattern

**Cons**:
- Multiple lists to manage
- Harder to get organization-wide asset reports
- Code complexity for dynamic list naming

**Recommendation**: Use **Option 1** (single centralized list) because:
1. Assets are organizational resources that may move between divisions
2. Your current Supabase model uses a single table with division filtering
3. Easier to generate reports and analytics
4. Admins need to see all assets across the organization

---

## SharePoint List Schema

### Assets List Structure

| Column Name | SharePoint Type | Required | Notes |
|------------|-----------------|----------|-------|
| **Title** | Single line of text | Yes | Maps to `name` in Supabase |
| ID | Number | Auto | Auto-generated by SharePoint |
| AssetID | Single line of text | No | Custom asset identifier (e.g., "324", "326") |
| Type | Choice | Yes | Desktop PC, Laptop, PC Monitor, Desk Phone, etc. |
| Brand | Single line of text | No | ACER, AOC, Dell, HP, etc. |
| Model | Single line of text | No | Travel Mate P238 Series, V226HQL, etc. |
| SerialNumber | Single line of text | No | Unique serial number |
| Condition | Choice | No | Good, Fair, Poor, Excellent, Needs Repair |
| AssignedTo | Person or Group | No | Person currently assigned |
| AssignedToEmail | Single line of text | No | Email of assigned person |
| AssignedDate | Date and Time | No | Date asset was assigned |
| Unit | Choice | No | IT, HR, Finance, etc. |
| Division | Choice | No | Division name |
| DivisionID | Single line of text | No | Links to divisions table |
| Description | Multiple lines of text | No | Asset description |
| PurchaseDate | Date and Time | No | Date asset was purchased |
| PurchaseCost | Number | No | Purchase price (PNG Kina) |
| DepreciatedValue | Number | No | Current depreciated value |
| Vendor | Single line of text | No | Vendor/supplier name |
| WarrantyExpiryDate | Date and Time | No | Warranty expiration |
| ExpiryDate | Date and Time | No | Asset lifecycle expiry |
| LifeExpectancyYears | Number | No | Expected lifespan in years |
| YTDUsage | Single line of text | No | Year-to-date usage info |
| Notes | Multiple lines of text | No | Additional notes |
| AdminComments | Multiple lines of text | No | Admin-only comments |
| InvoiceURL | Hyperlink | No | Link to invoice document |
| BarcodeURL | Hyperlink | No | Link to barcode image |
| ImageURL | Hyperlink | No | Link to asset image |
| CreatedBy | Person or Group | Auto | Auto-filled by SharePoint |
| Created | Date and Time | Auto | Auto-filled by SharePoint |
| ModifiedBy | Person or Group | Auto | Auto-filled by SharePoint |
| Modified | Date and Time | Auto | Auto-filled by SharePoint |
| IsDeleted | Yes/No | No | Soft delete flag (default: No) |
| DeletedAt | Date and Time | No | Soft delete timestamp |
| DeletedBy | Person or Group | No | Person who soft-deleted |

### Choice Field Options

**Type** options:
- Desktop PC
- Laptop
- PC Monitor
- Desk Phone
- Printer
- Scanner
- Tablet
- Projector
- Networking Equipment
- Server
- Other

**Condition** options:
- Excellent
- Good
- Fair
- Poor
- Needs Repair
- Out of Service

**Unit** options:
- IT
- HR
- Finance
- Operations
- Administration
- Legal
- Other

---

## Architecture Design

### 1. Service Layer Architecture

Following the HR module pattern, create a dedicated SharePoint service:

```
src/services/
  â””â”€â”€ assetsSharePointService.ts   (New - handles all SharePoint operations)

src/hooks/
  â””â”€â”€ useAssetsSharePoint.ts        (New - React hook for assets)

src/integrations/sharepoint/
  â””â”€â”€ assetsService.ts              (New - alternative location)
```

### 2. Data Flow (New Architecture)

```
Frontend Component (AssetManagementNew.tsx)
    â†“
useAssetsSharePoint Hook
    â†“
AssetsSharePointService Class
    â†“
Microsoft Graph Client (authenticated via MSAL)
    â†“
Microsoft Graph API
    â†“
SharePoint Online - Assets List
```

### 3. Authentication Flow

```
User Login â†’ MSAL Authentication â†’ Access Token
    â†“
Graph Client initialized with token
    â†“
AssetsSharePointService uses Graph Client
    â†“
Automatic token refresh via MSAL
```

### 4. Role-Based Filtering

**Admin Users**:
```typescript
// Fetch ALL assets (no filter)
const allAssets = await graphClient
  .api(`/sites/${siteId}/lists/${listId}/items`)
  .expand('fields')
  .get();
```

**Regular Users**:
```typescript
// Filter by AssignedToEmail on client-side
const userAssets = allAssets.filter(item =>
  item.fields.AssignedToEmail === currentUserEmail
);
```

**Why Client-Side Filtering?**
- SharePoint requires indexed columns for server-side filtering
- Person/Group fields are complex to filter via Graph API
- Simpler implementation
- Better performance for datasets < 5000 items

---

## Implementation Phases

### Phase 1: SharePoint Foundation (Week 1)

**Goal**: Create SharePoint infrastructure

1. **Create Assets List**
   - Navigate to SharePoint site
   - Create new list named "Assets"
   - Add all columns from schema above
   - Configure choice fields with options

2. **Test Data Migration**
   - Manually add 5-10 test assets
   - Verify all fields map correctly
   - Test filtering and sorting

3. **Document Creation**
   - Create document library for asset images (if not exists)
   - Create folder structure: `/Assets/Images/`, `/Assets/Invoices/`, `/Assets/Barcodes/`

**Deliverables**:
- âœ… Assets list created with full schema
- âœ… 10 test assets added
- âœ… Document library structure ready

---

### Phase 2: Service Layer Development (Week 2)

**Goal**: Build SharePoint integration code

1. **Create AssetsSharePointService**
   ```typescript
   // src/services/assetsSharePointService.ts
   export class AssetsSharePointService {
     private client: Client;
     private siteId: string | null = null;
     private listId: string | null = null;

     constructor(client: Client) {
       this.client = client;
     }

     async initialize(): Promise<void> { }
     async getAssets(userEmail?: string, isAdmin?: boolean): Promise<Asset[]> { }
     async getAssetById(id: string): Promise<Asset | null> { }
     async addAsset(asset: Partial<Asset>): Promise<Asset> { }
     async updateAsset(id: string, updates: Partial<Asset>): Promise<Asset> { }
     async deleteAsset(id: string, userEmail: string): Promise<boolean> { }
     async restoreAsset(id: string): Promise<Asset> { }
   }
   ```

2. **Create React Hook**
   ```typescript
   // src/hooks/useAssetsSharePoint.ts
   export function useAssetsSharePoint() {
     const [assets, setAssets] = useState<Asset[]>([]);
     const [loading, setLoading] = useState(true);
     const [error, setError] = useState<Error | null>(null);
     const { graphClient } = useGraphClient(); // Reuse existing

     // Implementation...
   }
   ```

3. **Type Mapping**
   - Create SharePoint-to-App type converters
   - Handle Person/Group field complexities
   - Map SharePoint field names to app field names

**Deliverables**:
- âœ… AssetsSharePointService implemented
- âœ… useAssetsSharePoint hook created
- âœ… Type converters working
- âœ… Unit tests written

---

### Phase 3: Frontend Integration (Week 3)

**Goal**: Update UI components to use SharePoint

1. **Create Feature Flag**
   ```typescript
   // src/config/features.ts
   export const FEATURES = {
     USE_SHAREPOINT_ASSETS: false, // Toggle migration
   };
   ```

2. **Update AssetManagementNew.tsx**
   - Add conditional logic to use SharePoint or Supabase
   - Maintain existing UI/UX
   - Test all CRUD operations

3. **Update Other Asset Components**
   - AssetsPage.tsx
   - AdminAssetsPage.tsx
   - Asset modals and dialogs

**Deliverables**:
- âœ… Feature flag implemented
- âœ… Dual-source support (Supabase + SharePoint)
- âœ… All components updated
- âœ… No breaking changes

---

### Phase 4: Data Migration (Week 4)

**Goal**: Migrate all 161 assets from Supabase to SharePoint

**Migration Script Approach**:

```typescript
// scripts/migrateAssetsToSharePoint.ts
async function migrateAssets() {
  // 1. Fetch all assets from Supabase
  const supabaseAssets = await supabase.from('assets').select('*');

  // 2. Initialize SharePoint service
  const spService = new AssetsSharePointService(graphClient);
  await spService.initialize();

  // 3. Migrate in batches
  for (const asset of supabaseAssets) {
    const sharePointAsset = convertToSharePointFormat(asset);
    await spService.addAsset(sharePointAsset);
    console.log(`Migrated asset: ${asset.name}`);
  }
}
```

**Migration Steps**:
1. Run migration script in development environment
2. Verify all 161 assets migrated correctly
3. Check data integrity (no data loss)
4. Test filtering by user/admin
5. Validate all field mappings
6. Compare counts: Supabase (161) = SharePoint (161)

**Data Validation Checklist**:
- [ ] All 161 assets present in SharePoint
- [ ] All fields populated correctly
- [ ] Images/documents linked properly
- [ ] User assignments correct
- [ ] Admin can see all assets
- [ ] Regular users see only their assets
- [ ] No duplicate records
- [ ] Soft-deleted assets migrated with IsDeleted=Yes

**Deliverables**:
- âœ… Migration script completed
- âœ… All 161 assets in SharePoint
- âœ… Data validation passed
- âœ… Backup of Supabase data taken

---

### Phase 5: Testing & Validation (Week 5)

**Goal**: Comprehensive testing before production

1. **Functional Testing**
   - Create new asset
   - Edit existing asset
   - Delete asset (soft delete)
   - Restore deleted asset
   - Search/filter assets
   - Sort by columns
   - Pagination
   - View asset details

2. **Permission Testing**
   - Admin sees all 161 assets
   - User A sees only their assets
   - User B sees only their assets
   - No cross-user data leaks

3. **Performance Testing**
   - Load time for 161 assets
   - Filter performance
   - Search performance
   - Concurrent user access

4. **Integration Testing**
   - Asset images upload/display
   - Invoice document links
   - Real-time updates (if implemented)
   - Export to Excel functionality

**Deliverables**:
- âœ… All tests passing
- âœ… Performance benchmarks met
- âœ… Security validation complete
- âœ… User acceptance testing done

---

### Phase 6: Production Deployment (Week 6)

**Goal**: Go live with SharePoint assets

1. **Pre-Deployment**
   - Final data sync from Supabase
   - Backup both systems
   - Notify users of maintenance window

2. **Deployment**
   - Enable feature flag: `USE_SHAREPOINT_ASSETS = true`
   - Deploy frontend code
   - Monitor for errors
   - Watch real-time logs

3. **Post-Deployment**
   - Verify all features working
   - Check user access
   - Monitor performance
   - Collect user feedback

4. **Supabase Deprecation**
   - Keep Supabase assets table read-only for 30 days
   - Mark as deprecated in code
   - Plan final decommission

**Deliverables**:
- âœ… Production deployment successful
- âœ… All users migrated
- âœ… No critical issues
- âœ… Supabase backup maintained

---

## Data Migration Process

### Step-by-Step Migration Script

```typescript
import { createClient } from '@supabase/supabase-js';
import { Client } from '@microsoft/microsoft-graph-client';
import { AssetsSharePointService } from './services/assetsSharePointService';

// Supabase client
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// Field mapping from Supabase to SharePoint
const FIELD_MAPPING = {
  // Supabase â†’ SharePoint
  'id': 'AssetID',  // Store Supabase ID as custom field
  'name': 'Title',
  'type': 'Type',
  'brand': 'Brand',
  'model': 'Model',
  'serial_number': 'SerialNumber',
  'condition': 'Condition',
  'assigned_to': 'AssignedTo',
  'assigned_to_email': 'AssignedToEmail',
  'assigned_date': 'AssignedDate',
  'unit': 'Unit',
  'division': 'Division',
  'division_id': 'DivisionID',
  'description': 'Description',
  'purchase_date': 'PurchaseDate',
  'purchase_cost': 'PurchaseCost',
  'depreciated_value': 'DepreciatedValue',
  'vendor': 'Vendor',
  'warranty_expiry_date': 'WarrantyExpiryDate',
  'expiry_date': 'ExpiryDate',
  'life_expectancy_years': 'LifeExpectancyYears',
  'ytd_usage': 'YTDUsage',
  'notes': 'Notes',
  'admin_comments': 'AdminComments',
  'invoice_url': 'InvoiceURL',
  'barcode_url': 'BarcodeURL',
  'image_url': 'ImageURL',
  'is_deleted': 'IsDeleted',
  'deleted_at': 'DeletedAt',
  'deleted_by': 'DeletedBy',
  // Audit fields handled automatically by SharePoint
};

async function migrateAllAssets() {
  console.log('ðŸš€ Starting assets migration...');

  try {
    // 1. Fetch all assets from Supabase (including soft-deleted)
    const { data: supabaseAssets, error } = await supabase
      .from('assets')
      .select('*');

    if (error) throw error;

    console.log(`ðŸ“Š Found ${supabaseAssets.length} assets in Supabase`);

    // 2. Initialize SharePoint service
    const graphClient = // ... get authenticated client
    const spService = new AssetsSharePointService(graphClient);
    await spService.initialize();

    // 3. Migrate each asset
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < supabaseAssets.length; i++) {
      const asset = supabaseAssets[i];

      try {
        console.log(`[${i + 1}/${supabaseAssets.length}] Migrating: ${asset.name}`);

        // Convert to SharePoint format
        const spAsset = convertToSharePointFormat(asset);

        // Add to SharePoint
        await spService.addAsset(spAsset);

        successCount++;
        console.log(`âœ… Success: ${asset.name}`);

        // Rate limiting - avoid throttling
        await sleep(100); // 100ms delay between requests

      } catch (err) {
        errorCount++;
        console.error(`âŒ Failed to migrate ${asset.name}:`, err);
        // Log to file for manual review
        logMigrationError(asset, err);
      }
    }

    console.log(`\nâœ… Migration complete!`);
    console.log(`   Success: ${successCount}`);
    console.log(`   Errors: ${errorCount}`);
    console.log(`   Total: ${supabaseAssets.length}`);

  } catch (error) {
    console.error('ðŸ’¥ Migration failed:', error);
    throw error;
  }
}

function convertToSharePointFormat(supabaseAsset: any): any {
  const spAsset: any = {};

  for (const [supabaseField, sharePointField] of Object.entries(FIELD_MAPPING)) {
    const value = supabaseAsset[supabaseField];

    if (value !== null && value !== undefined) {
      // Handle special field types
      if (sharePointField === 'AssignedTo' && value) {
        // Convert name to Person/Group lookup (requires user email)
        spAsset[sharePointField] = supabaseAsset.assigned_to_email;
      } else {
        spAsset[sharePointField] = value;
      }
    }
  }

  return spAsset;
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function logMigrationError(asset: any, error: any): void {
  const errorLog = {
    timestamp: new Date().toISOString(),
    assetId: asset.id,
    assetName: asset.name,
    error: error.message,
    stack: error.stack,
  };

  // Append to error log file
  fs.appendFileSync(
    'migration-errors.log',
    JSON.stringify(errorLog, null, 2) + '\n'
  );
}
```

### Migration Validation

After migration, run validation queries:

```typescript
async function validateMigration() {
  // 1. Count comparison
  const { count: supabaseCount } = await supabase
    .from('assets')
    .select('*', { count: 'exact', head: true });

  const sharePointAssets = await spService.getAssets(null, true); // Admin view
  const sharePointCount = sharePointAssets.length;

  console.log(`Supabase: ${supabaseCount} assets`);
  console.log(`SharePoint: ${sharePointCount} assets`);

  if (supabaseCount !== sharePointCount) {
    console.error('âŒ Count mismatch!');
    return false;
  }

  // 2. Spot check random assets
  const randomAssets = getRandomSample(sharePointAssets, 10);

  for (const spAsset of randomAssets) {
    const { data: supabaseAsset } = await supabase
      .from('assets')
      .select('*')
      .eq('id', spAsset.AssetID)
      .single();

    // Compare key fields
    if (supabaseAsset.name !== spAsset.Title) {
      console.error(`âŒ Mismatch for asset ${spAsset.AssetID}`);
      return false;
    }
  }

  console.log('âœ… Validation passed!');
  return true;
}
```

---

## Code Changes Required

### 1. New Files to Create

```
src/services/assetsSharePointService.ts         (Main service class)
src/hooks/useAssetsSharePoint.ts                (React hook)
src/types/sharepoint-assets.ts                  (TypeScript types)
scripts/migrateAssetsToSharePoint.ts            (Migration script)
```

### 2. Files to Modify

**src/pages/AssetManagementNew.tsx**
```typescript
// Before
const { data: assets, loading } = useAssetsData();

// After
const USE_SHAREPOINT = import.meta.env.VITE_USE_SHAREPOINT_ASSETS === 'true';

const {
  data: assets,
  loading
} = USE_SHAREPOINT
  ? useAssetsSharePoint()
  : useAssetsData();
```

**src/components/assets/AssetsPage.tsx**
```typescript
// Similar dual-source pattern
```

**src/hooks/useSupabaseData.tsx**
```typescript
// Add deprecation notice
// Keep for backward compatibility during transition
```

### 3. Environment Variables

Add to `.env`:
```bash
VITE_USE_SHAREPOINT_ASSETS=false  # Set to true after migration
VITE_SHAREPOINT_SITE_PATH=/sites/scpngintranet
VITE_SHAREPOINT_ASSETS_LIST=Assets
```

---

## Testing Strategy

### 1. Unit Tests

```typescript
describe('AssetsSharePointService', () => {
  it('should fetch all assets for admin', async () => {
    const assets = await service.getAssets(null, true);
    expect(assets).toHaveLength(161);
  });

  it('should filter assets by user email', async () => {
    const userAssets = await service.getAssets('user@example.com', false);
    expect(userAssets.every(a => a.AssignedToEmail === 'user@example.com')).toBe(true);
  });

  it('should add new asset', async () => {
    const newAsset = { Title: 'Test Laptop', Type: 'Laptop' };
    const created = await service.addAsset(newAsset);
    expect(created.Title).toBe('Test Laptop');
  });
});
```

### 2. Integration Tests

Test complete user flows:
- Admin views all assets
- User creates asset
- User edits their asset
- User cannot edit other user's asset
- Soft delete works correctly
- Restore works correctly

### 3. Performance Tests

```typescript
// Load test: Measure time to fetch 161 assets
const start = performance.now();
const assets = await service.getAssets();
const end = performance.now();
console.log(`Load time: ${end - start}ms`);
// Target: < 2000ms
```

---

## Rollback Plan

### If Migration Fails

1. **Immediate Rollback**
   ```bash
   # Set feature flag to false
   VITE_USE_SHAREPOINT_ASSETS=false

   # Redeploy previous version
   git checkout <previous-commit>
   npm run build
   npm run deploy
   ```

2. **Data Integrity**
   - Supabase data remains unchanged
   - No data loss risk
   - Can retry migration after fixing issues

3. **User Communication**
   - Notify users of temporary Supabase fallback
   - Explain rollback reason
   - Provide ETA for retry

### Recovery Time Objective (RTO)
- **Target**: < 15 minutes
- **Method**: Feature flag toggle + redeploy

---

## Success Criteria

### Migration Success Metrics

âœ… **Data Completeness**: All 161 assets migrated
âœ… **Zero Data Loss**: All fields preserved
âœ… **Performance**: Page load < 2 seconds
âœ… **Access Control**: Users see only their assets
âœ… **Functionality**: All CRUD operations working
âœ… **User Acceptance**: No critical bugs reported

### Post-Migration Monitoring

Monitor for 2 weeks:
- Error rates
- API response times
- User feedback
- SharePoint throttling issues
- Authentication failures

---

## Timeline Summary

| Phase | Duration | Key Deliverables |
|-------|----------|------------------|
| 1. SharePoint Foundation | 1 week | Assets list created, 10 test assets |
| 2. Service Layer | 1 week | AssetsSharePointService complete |
| 3. Frontend Integration | 1 week | UI updated, feature flag ready |
| 4. Data Migration | 1 week | All 161 assets in SharePoint |
| 5. Testing | 1 week | All tests passing |
| 6. Production Deployment | 1 week | Live on SharePoint |
| **Total** | **6 weeks** | Full migration complete |

---

## Next Steps

1. **Review this plan** - Confirm approach and timeline
2. **Create SharePoint Assets list** - Start Phase 1
3. **Develop service layer** - Implement AssetsSharePointService
4. **Test with sample data** - Validate approach works
5. **Execute migration** - Move all 161 assets
6. **Deploy to production** - Go live

---

## Questions to Consider

1. **Do you want a single Assets list or division-specific lists?**
   - Recommendation: Single list (simpler)

2. **Should we migrate images/documents to SharePoint?**
   - Current: Supabase storage
   - Future: SharePoint document library

3. **Do you need real-time updates?**
   - Graph API webhooks (complex)
   - Polling (simpler)
   - Manual refresh (simplest)

4. **What about historical audit data?**
   - SharePoint has built-in version history
   - May not need custom audit fields

5. **Phased rollout or all at once?**
   - Test with IT division first
   - Or migrate all 161 assets together

---

**Document Version**: 1.0
**Last Updated**: 2025-10-21
**Author**: Claude
**Status**: Draft - Awaiting Review
